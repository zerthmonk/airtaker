###### как запускать:

- скопировать `.env.template` в `.env`
- поправить значения переменных
- запустить `docker-compose up` (для быстрого развертывания Postgres и билда фронтенда)
- **ИЛИ** указать `DB_HOST` `DB_PORT` для своей базы, если она уже есть, а фронт собрать как описано в `frontent/README.md`
- `./run-django.sh` запустит тестовый сервер (**внимание**: `host:port` прописан внизу скрипта)

###### почему Django: 

- кастомные команды, в которые можно завернуть скрипт получения данных
- Django ORM я умею быстрее, чем SQLAlchemy

###### проблемы и особенности

- использовал Джанговые unit tests вместо django-pytest из-за сложностей с доступом к базе у pytest
- но стилистику по привычке использовал как в pytest, поэтому в тестах смешанный CamelCase и snake_case - некрасиво
- не завелась `wait-for-db` команда (которая говорила подождать, если база недоступна), почему -
так и не понял, вынес ее из кода вообще
- проблема с переменной `$DJANGO_LISTEN` внизу `run-django.sh` - потратил достаточно времени на дебаг, 
но работает через раз. в итоге забил и захардкодил.